---
layout: default
---

<h2>Source Formats</h2>

Various Cantaloupe processors support several other formats than those listed here; what follows are mainly just notes.</p>

<h3 id="JPEG">JPEG</h3>

<p>It should be possible to use TurboJPEG (high-level API over <a href="http://www.libjpeg-turbo.org">libjpeg-turbo</a>) with Java2dProcessor to hardware-accelerate JPEG coding. To do so, include the <a href="https://github.com/geosolutions-it/imageio-ext/wiki/TurboJPEG-plugin">TurboJPEG plugin JAR</a> in your classpath, and compile libjpeg-turbo with Java support (using the <code>--with-java</code>
configuration option). (The author has not tried this.)</p>

<h3 id="JPEG2000">JPEG2000</h3>

<p>JPEG2000 uses advanced compression techniques to enable fast reduced-scale and region-of-interest decoding. In theory, and with a performant decoder, JPEG2000 is well-suited for extremely large source images.</p>

<p><a href="processors.html#KakaduProcessor">KakaduProcessor</a> is the most efficient processor for this format, and it performs very well, even with huge images.</p>

<p><a href="processors.html#OpenJpegProcessor">OpenJpegProcessor</a> uses the <a href="http://www.openjpeg.org">OpenJPEG</a> decoder, which is generally considered, as of this writing, to be the fastest open-source JPEG2000 decoder. (<a href="processors.html#ImageMagickProcessor">ImageMagickProcessor</a>'s JPEG2000 delegate, if installed, will also use the OpenJPEG library, but less efficiently as it won't use its region-extraction or level-reduction features.)</p>

<p><a href="processors.html#GraphicsMagickProcessor">GraphicsMagickProcessor</a> can read and write JPEG2000 using JasPer, if the necessary plugin is installed. This will probably not be fast enough to be usable for most purposes.</p>

<p>See <a href="processors.html#JaiProcessor">JaiProcessor</a> for notes on the mediaLib accelerator.</p>

<h3 id="TIFF">TIFF</h3>

<p>TIFF is a common format that most processors can read. However, there are some conditions that source images must meet in order to be delivered efficiently.</p>

<h4>Strip-Based vs. Tile-Based</h4>

<p>The <a href="http://partners.adobe.com/public/developer/en/tiff/TIFF6.pdf">Adobe TIFF 6.0 specification</a> permits arrangements of image data in either strips or tiles. Most TIFF encoders produce strip-based TIFFs unless told to do otherwise. These are less efficient to read, especially as their size increases. <strong>High-resolution TIFFs should be tile-based</strong> in order to permit efficient region extraction. An easy way to check is with the <span class="filename">tiffdump</span> utility:</p>

<pre>$ tiffdump image.tif</pre>

<p>For strip-based TIFFs, this will print out some information including <code>StripOffsets</code>, <code>StripByteCounts</code>, and so on. For tile-based TIFFs, it will print <code>TileOffsets</code>, <code>TileByteCounts</code>, and so on, instead.</p>

<h4>Multi-Resolution (Pyramidal) TIFF</h4>

<p>Multi-resolution TIFF is a special type of TIFF file that can improve reader efficiency at reduced scales. In addition to the main image, a multi-resolution TIFF file will contain a sequence of progressively half-sized sub-images: for example, a 10000&times;10000 pixel main image would include derivatives of 5000&times;5000 pixels, 2500&times;2500 pixels, 1250&times;1250 pixels, and so on, all embedded inside the same file.</p>

<p>Each of the levels in a multi-resolution TIFF file can be striped or tiled just like in a mono-resolution file. Tiled and pyramidal encodings are complementary: the former improves efficiency with reduced regions at large scales, and the latter improves efficiency at reduced scales. Therefore, for efficient deep zooming, TIFF images need to be pyramidal, and each level of the pyramid should be tiled.</p>

<h4>Processor Considerations</h4>

<p>To reiterate: most processors can "read the TIFF format," but not all can read it efficiently. Currently, <a href="processors.html#Java2dProcessor">Java2dProcessor</a> and <a href="processors.html#JaiProcessor">JaiProcessor</a> both support multi-resolution TIFF, which is to say that they actually do read the embedded sub-images and choose the smallest one that can fulfill the request. Java2dProcessor additionally exploits tiled sub-images, so it should currently be the processor of choice for dealing with high-resolution TIFF images.</p>
